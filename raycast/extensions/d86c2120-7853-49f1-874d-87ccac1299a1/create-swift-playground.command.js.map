{
  "version": 3,
  "sources": ["../node_modules/dedent/dist/dedent.js", "../node_modules/untildify/index.js", "../src/create-swift-playground.command.tsx", "../src/components/xcode-create-swift-playground/xcode-create-swift-playground-form.component.tsx", "../src/models/swift-playground/xcode-swift-playground-platform.model.ts", "../src/shared/exec-async.ts", "../src/services/xcode-swift-playground.service.ts", "../src/models/swift-playground/xcode-swift-playground-template.model.ts", "../src/shared/fs-async.ts", "../src/shared/get-preferences.ts", "../src/shared/operation-with-user-feedback.ts", "../node_modules/tildify/index.js"],
  "sourcesContent": ["\"use strict\";\n\nfunction dedent(strings) {\n\n  var raw = void 0;\n  if (typeof strings === \"string\") {\n    // dedent can be used as a plain function\n    raw = [strings];\n  } else {\n    raw = strings.raw;\n  }\n\n  // first, perform interpolation\n  var result = \"\";\n  for (var i = 0; i < raw.length; i++) {\n    result += raw[i].\n    // join lines when there is a suppressed newline\n    replace(/\\\\\\n[ \\t]*/g, \"\").\n\n    // handle escaped backticks\n    replace(/\\\\`/g, \"`\");\n\n    if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {\n      result += arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    }\n  }\n\n  // now strip indentation\n  var lines = result.split(\"\\n\");\n  var mindent = null;\n  lines.forEach(function (l) {\n    var m = l.match(/^(\\s+)\\S+/);\n    if (m) {\n      var indent = m[1].length;\n      if (!mindent) {\n        // this is the first indented line\n        mindent = indent;\n      } else {\n        mindent = Math.min(mindent, indent);\n      }\n    }\n  });\n\n  if (mindent !== null) {\n    result = lines.map(function (l) {\n      return l[0] === \" \" ? l.slice(mindent) : l;\n    }).join(\"\\n\");\n  }\n\n  // dedent eats leading and trailing whitespace too\n  result = result.trim();\n\n  // handle escaped newlines at the end to ensure they don't get stripped too\n  return result.replace(/\\\\n/g, \"\\n\");\n}\n\nif (typeof module !== \"undefined\") {\n  module.exports = dedent;\n}\n", "'use strict';\nconst os = require('os');\n\nconst homeDirectory = os.homedir();\n\nmodule.exports = pathWithTilde => {\n\tif (typeof pathWithTilde !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof pathWithTilde}`);\n\t}\n\n\treturn homeDirectory ? pathWithTilde.replace(/^~(?=$|\\/|\\\\)/, homeDirectory) : pathWithTilde;\n};\n", "import { XcodeCreateSwiftPlaygroundForm } from \"./components/xcode-create-swift-playground/xcode-create-swift-playground-form.component\";\n\nexport default () => <XcodeCreateSwiftPlaygroundForm />;\n", "import { Action, ActionPanel, Form, Navigation, showHUD, Toast, useNavigation } from \"@raycast/api\";\nimport { XcodeSwiftPlaygroundPlatform } from \"../../models/swift-playground/xcode-swift-playground-platform.model\";\nimport { XcodeSwiftPlaygroundService } from \"../../services/xcode-swift-playground.service\";\nimport { XcodeSwiftPlaygroundTemplate } from \"../../models/swift-playground/xcode-swift-playground-template.model\";\nimport { operationWithUserFeedback } from \"../../shared/operation-with-user-feedback\";\nimport { XcodeSwiftPlaygroundCreationParameters } from \"../../models/swift-playground/xcode-swift-playground-creation-parameters.model\";\nimport tildify from \"tildify\";\nimport { useState } from \"react\";\n\n/**\n * Xcode create Swift Playground Form\n */\nexport function XcodeCreateSwiftPlaygroundForm() {\n  const navigation = useNavigation();\n  const [nameError, setNameError] = useState<string | undefined>();\n  const [locationError, setLocationError] = useState<string | undefined>();\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm\n            title={\"Open or create Swift Playground\"}\n            onSubmit={(formValues) => submit(formValues, navigation, false)}\n          />\n          <Action.SubmitForm\n            title={\"Create Swift Playground\"}\n            onSubmit={(formValues) => submit(formValues, navigation, true)}\n          />\n        </ActionPanel>\n      }\n    >\n      <Form.TextField\n        id=\"name\"\n        title=\"Name\"\n        defaultValue=\"MyPlayground\"\n        error={nameError}\n        onChange={() => {\n          if (nameError && nameError.length > 0) {\n            setNameError(undefined);\n          }\n        }}\n        onBlur={(event) => {\n          if (event.target.value?.length == 0) {\n            setNameError(\"Please enter a name.\");\n          } else if (nameError && nameError.length > 0) {\n            setNameError(undefined);\n          }\n        }}\n      />\n      <Form.TextField\n        id=\"location\"\n        title=\"Location\"\n        defaultValue={XcodeSwiftPlaygroundService.defaultSwiftPlaygroundLocation}\n        error={locationError}\n        onChange={() => {\n          if (locationError && locationError.length > 0) {\n            setLocationError(undefined);\n          }\n        }}\n        onBlur={(event) => {\n          if (event.target.value?.length == 0) {\n            setLocationError(\"Please enter a location.\");\n          } else if (locationError && locationError.length > 0) {\n            setLocationError(undefined);\n          }\n        }}\n      />\n      <Form.Dropdown id=\"platform\" title=\"Platform\" defaultValue={XcodeSwiftPlaygroundPlatform.iOS}>\n        {Object.keys(XcodeSwiftPlaygroundPlatform)\n          .map((platform) => platform.toLocaleLowerCase())\n          .map((platform) => (\n            <Form.Dropdown.Item key={platform} value={platform} title={platform.replace(\"os\", \"OS\")} />\n          ))}\n      </Form.Dropdown>\n      <Form.Dropdown id=\"template\" title=\"Template\" defaultValue={XcodeSwiftPlaygroundTemplate.Empty}>\n        {Object.keys(XcodeSwiftPlaygroundTemplate).map((template) => (\n          <Form.Dropdown.Item key={template} value={template} title={template} />\n        ))}\n      </Form.Dropdown>\n      <Form.Checkbox id=\"open\" label=\"Open in Xcode after creation\" defaultValue={true} />\n    </Form>\n  );\n}\n\n/**\n * Submit Form Values\n * @param formValues The Form values\n * @param navigation The Navigation\n * @param forceCreate Bool value if creation of a Swift Playground should be enforced\n */\nasync function submit(formValues: Form.Values, navigation: Navigation, forceCreate: boolean) {\n  if (!formValues.name || !formValues.location) {\n    return;\n  }\n  const operationResult = await operationWithUserFeedback(\n    \"Creating Swift Playground\",\n    \"Swift Playground successfully created\",\n    \"An error occurred while trying to create the Swift Playground\",\n    async () => {\n      return await XcodeSwiftPlaygroundService.createSwiftPlayground(\n        formValues as XcodeSwiftPlaygroundCreationParameters,\n        forceCreate\n      );\n    }\n  );\n  // Check if operation failed\n  if (!operationResult.result) {\n    // Return out of function\n    return;\n  }\n  // Check if Swift Playground already exists and should not be opened\n  if (operationResult.result.alreadyExists && !formValues.open) {\n    // Inform user that the Playground already exists\n    operationResult.toast.style = Toast.Style.Failure;\n    operationResult.toast.title = \"Swift Playground already exists\";\n    // Return out of function\n    return;\n  }\n  // Initialize success message title\n  const successMessageTitle = [\n    \"Swift Playground\",\n    operationResult.result.alreadyExists ? \"opened\" : \"created\",\n    \"at\",\n    tildify(operationResult.result.path),\n  ].join(\" \");\n  // Check if Swift Playground should be opened after creation\n  if (formValues.open) {\n    try {\n      // Open Swift Playground\n      await operationResult.result.open();\n      // Show success HUD\n      await showHUD(successMessageTitle);\n    } catch {\n      // Show failure Toast\n      operationResult.toast.style = Toast.Style.Failure;\n      operationResult.toast.title = \"Swift Playground could not be opened\";\n    }\n  } else {\n    // Show success message\n    operationResult.toast.title = successMessageTitle;\n  }\n  // Pop to root\n  navigation.pop();\n}\n", "/**\n * XcodeSwiftPlaygroundPlatform\n */\nexport enum XcodeSwiftPlaygroundPlatform {\n  /**\n   * iOS\n   */\n  iOS = \"ios\",\n  /**\n   * macOS\n   */\n  macOS = \"macos\",\n  /**\n   * tvOS\n   */\n  tvOS = \"tvos\",\n}\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n/**\n * Spawns a shell then executes the command within that shell, buffering any generated output.\n */\nexport const execAsync = promisify(exec);\n", "import { XcodeSwiftPlaygroundCreationParameters } from \"../models/swift-playground/xcode-swift-playground-creation-parameters.model\";\nimport { XcodeSwiftPlayground } from \"../models/swift-playground/xcode-swift-playground.model\";\nimport { XcodeSwiftPlaygroundPlatform } from \"../models/swift-playground/xcode-swift-playground-platform.model\";\nimport { execAsync } from \"../shared/exec-async\";\nimport dedent from \"dedent\";\nimport { XcodeSwiftPlaygroundTemplate } from \"../models/swift-playground/xcode-swift-playground-template.model\";\nimport { existsAsync, makeDirectoryAsync, removeDirectoryAsync, writeFileAsync } from \"../shared/fs-async\";\nimport untildify from \"untildify\";\nimport * as Path from \"path\";\nimport { getPreferences } from \"../shared/get-preferences\";\n\n/**\n * XcodeSwiftPlaygroundService\n */\nexport class XcodeSwiftPlaygroundService {\n  /**\n   * The scaffold Swift Playground TemplateFiles\n   */\n  private static scaffoldTemplateFiles: TemplateFile[] = [\n    {\n      name: \"timeline\",\n      extension: \"xctimeline\",\n      contents: `\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <Timeline version=\"3.0\">\n         <TimelineItems>\n         </TimelineItems>\n      </Timeline>\n      `,\n    },\n    {\n      path: \"playground.xcworkspace\",\n      name: \"contents\",\n      extension: \"xcworkspacedata\",\n      contents: `\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <Workspace version=\"1.0\">\n        <FileRef location=\"group:self:\">\n        </FileRef>\n      </Workspace>\n      `,\n    },\n  ];\n\n  /**\n   * The default location where a Swift Playground should be created\n   */\n  static get defaultSwiftPlaygroundLocation(): string {\n    return getPreferences().playgroundDefaultLocation;\n  }\n\n  /**\n   * Create a new Swift Playground\n   * @param parameters The XcodeSwiftPlaygroundCreationParameters\n   * @param forceCreate Bool value if the creation of a Swift Playground should be enforced\n   */\n  static async createSwiftPlayground(\n    parameters: XcodeSwiftPlaygroundCreationParameters,\n    forceCreate: boolean\n  ): Promise<XcodeSwiftPlayground> {\n    const playgroundPath = await XcodeSwiftPlaygroundService.makeSwiftPlaygroundPath(\n      parameters.location,\n      parameters.name,\n      forceCreate\n    );\n    if (!forceCreate && (await existsAsync(playgroundPath))) {\n      return {\n        name: parameters.name,\n        path: playgroundPath,\n        alreadyExists: true,\n        open: () => {\n          return execAsync(`open ${playgroundPath}`).then();\n        },\n      };\n    }\n    // Make playground directory\n    await makeDirectoryAsync(playgroundPath);\n    // Initialize template files\n    const templateFiles = [\n      ...XcodeSwiftPlaygroundService.scaffoldTemplateFiles,\n      XcodeSwiftPlaygroundService.swiftSourceContentsTemplateFile(parameters.template),\n      XcodeSwiftPlaygroundService.contentsTemplateFile(parameters.platform),\n    ];\n    try {\n      // Create TemplateFiles in parallel\n      await Promise.all(\n        templateFiles.map(async (templateFile) => {\n          // Initialize file path with current playground path\n          let filePath = playgroundPath;\n          // Check if template file has a path\n          if (templateFile.path) {\n            // Join current file path with template file path\n            filePath = Path.join(filePath, templateFile.path);\n            // Make directory\n            await makeDirectoryAsync(filePath);\n          }\n          // Join current file path with file name\n          filePath = Path.join(filePath, [templateFile.name, templateFile.extension].join(\".\"));\n          // Write file\n          await writeFileAsync(filePath, dedent(templateFile.contents));\n        })\n      );\n    } catch (error) {\n      try {\n        // On error perform rollback\n        // Try to remove the playground directory\n        await removeDirectoryAsync(playgroundPath, { recursive: true });\n      } catch (error) {\n        // Log and ignore this error\n        // As we only try to clean up the Playground directory\n        // in case of an error\n        console.error(error);\n      }\n      // Re-Throw Error\n      throw error;\n    }\n    // Return Playground\n    return {\n      name: parameters.name,\n      path: playgroundPath,\n      alreadyExists: false,\n      open: () => {\n        return execAsync(`open ${playgroundPath}`).then();\n      },\n    };\n  }\n\n  /**\n   * Make a Swift Playground path for a given location and file name\n   * @param location location in which we want to save the playground file.\n   * @param filename filename of the created or opened playground file.\n   * @param forceCreate define if we want to force create or not.\n   */\n  private static async makeSwiftPlaygroundPath(\n    location: string,\n    filename: string,\n    forceCreate: boolean\n  ): Promise<string> {\n    let path = \"\";\n    let iteration = null;\n    const targetLocation = untildify(location);\n    do {\n      const dateString = new Date().toLocaleDateString().replaceAll(\"/\", \"-\").replaceAll(\".\", \"-\");\n      const name =\n        iteration == null\n          ? `${filename}-${dateString}.playground`\n          : `${filename}-${dateString}-${iteration}.playground`;\n      path = Path.join(targetLocation, name);\n      iteration = iteration == null ? 1 : iteration + 1;\n    } while ((await existsAsync(path)) && forceCreate);\n    return path;\n  }\n\n  /**\n   * The XCPlayground contents TemplateFile\n   * @param platform The XcodeSwiftPlaygroundPlatform\n   * @private\n   */\n  private static contentsTemplateFile(platform: XcodeSwiftPlaygroundPlatform): TemplateFile {\n    return {\n      name: \"contents\",\n      extension: \"xcplayground\",\n      contents: `\n      <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n      <playground version='5.0' \n                  target-platform='${platform.toLocaleLowerCase()}' \n                  buildActiveScheme='true' \n                  executeOnSourceChanges='false' \n                  importAppTypes='true'>\n          <timeline fileName='timeline.xctimeline'/>\n      </playground>\n      `,\n    };\n  }\n\n  /**\n   * Swift Source Contents TemplateFile\n   * @param template The XcodeSwiftPlaygroundTemplate\n   */\n  private static swiftSourceContentsTemplateFile(template: XcodeSwiftPlaygroundTemplate): TemplateFile {\n    let contents: string;\n    switch (template) {\n      case XcodeSwiftPlaygroundTemplate.Empty:\n        contents = \"import Foundation\\n\\n\";\n        break;\n      case XcodeSwiftPlaygroundTemplate.SwiftUI:\n        contents = `\n        import PlaygroundSupport\n        import SwiftUI\n        \n        struct ContentView: View {\n        \n            var body: some View {\n                Text(\"Hello World\")\n            }\n            \n        }\n        \n        PlaygroundPage.current.liveView = UIHostingController(rootView: ContentView())\n        `;\n        break;\n      case XcodeSwiftPlaygroundTemplate.UIKit:\n        contents = `\n        import Foundation\n        import PlaygroundSupport\n        import UIKit\n\n        class ViewController : UIViewController {\n          override func viewDidLoad() {\n            super.viewDidLoad()\n          }\n        }\n\n        let viewController = ViewController()\n        viewController.view.frame = CGRect(x: 0, y: 0, width: 300, height: 600)\n        PlaygroundPage.current.liveView = viewController\n        PlaygroundPage.current.needsIndefiniteExecution = true\n        `;\n        break;\n    }\n    return {\n      name: \"Contents\",\n      extension: \"swift\",\n      contents: contents,\n    };\n  }\n}\n\n/**\n * A Template File\n */\ninterface TemplateFile {\n  /**\n   * The optional path\n   */\n  path?: string;\n  /**\n   * The name of the file\n   */\n  name: string;\n  /**\n   * The file extension\n   */\n  extension: string;\n  /**\n   * The file contents\n   */\n  contents: string;\n}\n", "/**\n * Xcode Swift Playground Template\n */\nexport enum XcodeSwiftPlaygroundTemplate {\n  /**\n   * Empty\n   */\n  Empty = \"Empty\",\n  /**\n   * SwiftUI\n   */\n  SwiftUI = \"SwiftUI\",\n  /**\n   * UIKit\n   */\n  UIKit = \"UIKit\",\n}\n", "import fs from \"fs\";\nimport { PathLike } from \"node:fs\";\n\n/**\n * Exists\n */\nexport const existsAsync = (path: PathLike) => {\n  return fs.promises\n    .access(path, fs.constants.F_OK)\n    .then(() => true)\n    .catch(() => false);\n};\n\n/**\n * Read directory\n */\nexport const readDirectoryAsync = fs.promises.readdir;\n\n/**\n * Make directory\n */\nexport const makeDirectoryAsync = fs.promises.mkdir;\n\n/**\n * Remove directory\n */\nexport const removeDirectoryAsync = fs.promises.rm;\n\n/**\n * Read file\n */\nexport const readFileAsync = fs.promises.readFile;\n\n/**\n * Write file\n */\nexport const writeFileAsync = fs.promises.writeFile;\n\n/**\n * Delete file\n */\nexport const deleteFileAsync = fs.promises.rm;\n", "import { Preferences } from \"../models/preferences/preferences.model\";\nimport { getPreferenceValues } from \"@raycast/api\";\n\n/**\n * A function to retrieve the preferences\n */\nexport function getPreferences(): Preferences {\n  return getPreferenceValues<Preferences>();\n}\n", "import { showToast, Toast } from \"@raycast/api\";\n\n/**\n * OperationWithUserFeedback Result\n */\nexport interface OperationWithUserFeedbackResult<T> {\n  /**\n   * Bool value if operation succeeded or failed\n   */\n  isSuccess: boolean;\n  /**\n   * The optional generic Result\n   */\n  result?: T;\n  /**\n   * The Toast\n   */\n  toast: Toast;\n}\n\n/**\n * Perform an operation with user feedback while loading, on success and on failure\n * @param loadingTitle The loading title while the operation is running\n * @param successTitle The success title when the operation succeeded\n * @param failureTitle The failure title when the operation failed\n * @param operation The operation to perform\n */\nexport async function operationWithUserFeedback<T>(\n  loadingTitle: string,\n  successTitle: string,\n  failureTitle: string,\n  operation: () => Promise<T>\n): Promise<OperationWithUserFeedbackResult<T>> {\n  // Show Toast\n  const toast = await showToast({\n    style: Toast.Style.Animated,\n    title: loadingTitle,\n  });\n  try {\n    // Perform operation\n    const result = await operation();\n    // Show success Toast\n    toast.style = Toast.Style.Success;\n    toast.title = successTitle;\n    return {\n      isSuccess: true,\n      result: result,\n      toast: toast,\n    };\n  } catch (error) {\n    // Log error\n    console.error(error);\n    // Show failure Toast\n    toast.style = Toast.Style.Failure;\n    toast.title = failureTitle;\n    toast.message = `${error}`;\n    return {\n      isSuccess: false,\n      toast: toast,\n    };\n  }\n}\n", "import path from 'node:path';\nimport os from 'node:os';\n\nconst homeDirectory = os.homedir();\n\nexport default function tildify(absolutePath) {\n\tconst normalizedPath = path.normalize(absolutePath) + path.sep;\n\n\treturn (\n\t\tnormalizedPath.startsWith(homeDirectory)\n\t\t\t? normalizedPath.replace(homeDirectory + path.sep, `~${path.sep}`)\n\t\t\t: normalizedPath\n\t)\n\t\t.slice(0, -1);\n}\n"],
  "mappings": "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",
  "names": ["require_dedent", "__commonJSMin", "exports", "module", "dedent", "strings", "raw", "result", "i", "lines", "mindent", "l", "m", "indent", "require_untildify", "__commonJSMin", "exports", "module", "os", "homeDirectory", "pathWithTilde", "create_swift_playground_command_exports", "__export", "create_swift_playground_command_default", "__toCommonJS", "import_api", "XcodeSwiftPlaygroundPlatform", "import_child_process", "import_util", "execAsync", "import_dedent", "XcodeSwiftPlaygroundTemplate", "import_fs", "existsAsync", "path", "fs", "readDirectoryAsync", "makeDirectoryAsync", "removeDirectoryAsync", "readFileAsync", "writeFileAsync", "deleteFileAsync", "import_untildify", "Path", "import_api", "getPreferences", "XcodeSwiftPlaygroundService", "_XcodeSwiftPlaygroundService", "getPreferences", "parameters", "forceCreate", "playgroundPath", "existsAsync", "execAsync", "makeDirectoryAsync", "templateFiles", "templateFile", "filePath", "writeFileAsync", "dedent", "error", "removeDirectoryAsync", "location", "filename", "path", "iteration", "targetLocation", "untildify", "dateString", "name", "platform", "template", "contents", "import_api", "operationWithUserFeedback", "loadingTitle", "successTitle", "failureTitle", "operation", "toast", "result", "error", "import_node_path", "import_node_os", "homeDirectory", "os", "tildify", "absolutePath", "normalizedPath", "path", "import_react", "import_jsx_runtime", "XcodeCreateSwiftPlaygroundForm", "navigation", "nameError", "setNameError", "locationError", "setLocationError", "formValues", "submit", "event", "XcodeSwiftPlaygroundService", "XcodeSwiftPlaygroundPlatform", "platform", "XcodeSwiftPlaygroundTemplate", "template", "forceCreate", "operationResult", "operationWithUserFeedback", "successMessageTitle", "tildify", "import_jsx_runtime", "create_swift_playground_command_default", "XcodeCreateSwiftPlaygroundForm"]
}
